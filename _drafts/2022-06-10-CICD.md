---
layout: post
title: My first foray into CI/CD
date: 2022-06-10
categories: [CI/CD, Github Actions]
tags: [cicd,github,githubactions]
---

# My first foray into CI/CD
A few days ago, I came across a YouTube video that showed Jekyll generating a static site. This interested me and after doing some extra reading I found that it was also possible to create a blog as well. Even better than that, it is possible to host said blog for free on github.

## Some backstory
This blog originally started life as a WordPress blog on Amazon's AWS EC2 servers. However, once my free tier expired, I started getting a bill of around £7 per month for minimal traffic to the site. I had been using Linode servers for a few other projects and decided that I was going to migrate the blog to a ghost CMS site on their smallest nodes. This should have brought prices down to around £4 a month. But as always, migration was slow, and so I just ended up paying £11 for a blog split across 2 servers. Not ideal! So what to do now? Well, I've exported the contents of the WordPress blog and imported it to a stack running on my local docker server. I now plan to pull the relevant posts off the local server and migrate them into here. (There were a couple of post about how cheap the AWS servers were, which now in hindsight is not true.) During this process, I realized that GitHub Actions was a very good answer to maintaining a few docker images I have.

## So what are GitHub Actions?
GitHub actions are a way to streamline the deployment of software from the workspace where the code lives. So how does it work? Very simply, we put together a YAML file (which we also store in the repository) which has all the steps we need to build and publish our project. Sound simple so far? In theory, yes, it is quite simple. The complexity starts coming from how powerful and flexible it is. GitHub has a so-called marketplace (is it a marketplace if everything is free?) full of different actions that you can perform. From just sending a message to a new user, submitting their first PR to your repo, to a full-blown build and deployment of a game to the steam servers and everything in between. And because of how flexible the system is, we find there is most definitely more than one way to skin the cat. (Not sure if there's a more updated version of that expression?!) 

## First GitHub action
The first GitHub action I used was the default action that came with my Jekyll template. And taking a look at it, I thought, “How hard could it be?”. It turns out that the last of the three-step workflow called a 160 shell script that ran considerably more steps than I thought. However, that action was doing exactly what I needed it to do, so I didn't delve too much into it. Instead, I did a Google looking for some examples on how to build a Dockerfile.
It turns out actually building the Dockerfile isn't too hard. I already had docker commands written out for when I was building the images locally. So for a really quick start you can stick your command into a `run:` step and hey presto you have built your first docker image in the cloud. It's not quite that simple, but it's not far off. Here is a very basic example of building a docker image:
``` yml
name: Build docker image
on: [push]
jobs:
  push:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - run: docker build .
```
Let break down that code block and see what's going on here.
``` yml
name: Build docker image
on: [push]
```
The first line is pretty self-explanatory. It gives your workflow a name. This is nice as you can see it in the log of which events have run. The second line is a little more interesting and specifies what triggers the workflow to run. In our case, it is when someone pushed changes to the repo (or committed from the web interface). Starting early, there are even options for this. 
``` yml
on:
  push:
    branches: [ "main" ]
```
This snippet will only trigger the workflow when pushing changes into the main branch of the repo. Next we move on to the part that actually tells the runners (the name GitHub have given to the servers that do the work) what to do.
``` yml 
jobs:
  push:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - run: docker build .
```
Line 2 defines that this section is to be run when a push happens. Line 3 we tell the system what OS we would like to run the steps on. GitHub provides macOS, Linux, and Windows runners for our use. And finally, lines 4 through 6 (and onwards) are the steps that will be performed on that runner. For us, this is just to create a copy of the repo and then one simple command to build the docker image.